
diff --git a/lib/grunt/file.js b/lib/grunt/file.js
index 604736c..b6d3f0e 100644
--- a/lib/grunt/file.js
+++ b/lib/grunt/file.js
@@ -317,32 +317,39 @@ file.copy = function copy(srcpath, destpath, options) {
 
 // Read a file, optionally processing its content, then write the output.
 file._copy = function(srcpath, destpath, options) {
-  if (!options) { options = {}; }
-  // If a process function was specified, and noProcess isn't true or doesn't
-  // match the srcpath, process the file's source.
-  var process = options.process && options.noProcess !== true &&
-    !(options.noProcess && file.isMatch(options.noProcess, srcpath));
-  // If the file will be processed, use the encoding as-specified. Otherwise,
-  // use an encoding of null to force the file to be read/written as a Buffer.
-  var readWriteOptions = process ? options : {encoding: null};
-  // Actually read the file.
-  var contents = file.read(srcpath, readWriteOptions);
-  if (process) {
-    grunt.verbose.write('Processing source...');
+    if (!options) { options = {}; }
+    // Lock the source file to prevent changes during the copy process
+    var lock = lockfile.lock(srcpath);
     try {
-      contents = options.process(contents, srcpath, destpath);
-      grunt.verbose.ok();
-    } catch (e) {
-      grunt.verbose.error();
-      throw grunt.util.error('Error while processing "' + srcpath + '" file.', e);
+        // If a process function was specified, and noProcess isn't true or doesn't
+        // match the srcpath, process the file's source.
+        var process = options.process && options.noProcess !== true &&
+            !(options.noProcess && file.isMatch(options.noProcess, srcpath));
+        // If the file will be processed, use the encoding as-specified. Otherwise,
+        // use an encoding of null to force the file to be read/written as a Buffer.
+        var readWriteOptions = process ? options : {encoding: null};
+        // Actually read the file.
+        var contents = file.read(srcpath, readWriteOptions);
+        if (process) {
+            grunt.verbose.write('Processing source...');
+            try {
+                contents = options.process(contents, srcpath, destpath);
+                grunt.verbose.ok();
+            } catch (e) {
+                grunt.verbose.error();
+                throw grunt.util.error('Error while processing "' + srcpath + '" file.', e);
+            }
+        }
+        // Abort copy if the process function returns false.
+        if (contents === false) {
+            grunt.verbose.writeln('Write aborted.');
+        } else {
+            file.write(destpath, contents, readWriteOptions);
+        }
+    } finally {
+        // Unlock the file after copying is done
+        lockfile.unlock(lock);
     }
-  }
-  // Abort copy if the process function returns false.
-  if (contents === false) {
-    grunt.verbose.writeln('Write aborted.');
-  } else {
-    file.write(destpath, contents, readWriteOptions);
-  }
 };
 
 // Delete folders and files recursively
diff --git a/test/grunt/file_test.js b/test/grunt/file_test.js
index 0448f30..4c7539b 100644
--- a/test/grunt/file_test.js
+++ b/test/grunt/file_test.js
@@ -918,3 +918,19 @@ exports.file = {
     },
   }
 };
+exports['file._copy with locking'] = {
+    'test TOCTOU mitigation with locking': function(test) {
+        test.expect(1);
+        var srcpath = 'path/to/source/file.txt';
+        var destpath = 'path/to/destination/file.txt';
+        // Simulate a race condition scenario
+        setTimeout(function() {
+            fs.writeFileSync(srcpath, 'new content that should not affect copy');
+        }, 10);
+        // Perform the copy operation which should use locking
+        grunt.file._copy(srcpath, destpath, {});
+        var content = fs.readFileSync(destpath, 'utf8');
+        test.equal(content, 'original content of source file', 'file content should match expected original content');
+        test.done();
+    }
+};
