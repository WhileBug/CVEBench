
diff --git a/synapse/rest/media/v1/preview_html.py b/synapse/rest/media/v1/preview_html.py
index ed8f21a48..92b52d36c 100644
--- a/synapse/rest/media/v1/preview_html.py
+++ b/synapse/rest/media/v1/preview_html.py
@@ -303,14 +303,14 @@ def parse_html_description(tree: "etree.Element") -> Optional[str]:
 
 
 def _iterate_over_text(
-    tree: "etree.Element", *tags_to_ignore: Union[str, "etree.Comment"]
+    tree: "etree.Element", *tags_to_ignore: Union[str, "etree.Comment"], max_depth: int = 100, current_depth: int = 0
 ) -> Generator[str, None, None]:
     """Iterate over the tree returning text nodes in a depth first fashion,
-    skipping text nodes inside certain tags.
+    skipping text nodes inside certain tags. Stops recursion after max_depth.
     """
-    # This is basically a stack that we extend using itertools.chain.
-    # This will either consist of an element to iterate over *or* a string
-    # to be returned.
+    if current_depth > max_depth:
+        return  # Stop recursion if depth exceeds max_depth
+
     elements = iter([tree])
     while True:
         el = next(elements, None)
@@ -320,26 +320,20 @@ def _iterate_over_text(
         if isinstance(el, str):
             yield el
         elif el.tag not in tags_to_ignore:
-            # If the element isn't meant for display, ignore it.
             if el.get("role") in ARIA_ROLES_TO_IGNORE:
                 continue
 
-            # el.text is the text before the first child, so we can immediately
-            # return it if the text exists.
             if el.text:
                 yield el.text
 
-            # We add to the stack all the elements children, interspersed with
-            # each child's tail text (if it exists). The tail text of a node
-            # is text that comes *after* the node, so we always include it even
-            # if we ignore the child node.
             elements = itertools.chain(
-                itertools.chain.from_iterable(  # Basically a flatmap
+                itertools.chain.from_iterable(
                     [child, child.tail] if child.tail else [child]
                     for child in el.iterchildren()
                 ),
                 elements,
             )
+        current_depth += 1  # Increment depth for each recursive call
 
 
 def summarize_paragraphs(
diff --git a/tests/rest/media/v1/test_html_preview.py b/tests/rest/media/v1/test_html_preview.py
index ea9e5889b..725571f05 100644
--- a/tests/rest/media/v1/test_html_preview.py
+++ b/tests/rest/media/v1/test_html_preview.py
@@ -481,4 +481,14 @@ class MediaEncodingTestCase(unittest.TestCase):
         """,
             'text/html; charset="invalid"',
         )
-        self.assertEqual(list(encodings), ["utf-8", "cp1252"])
+from synapse.rest.media.v1.preview_html import _iterate_over_text
+
+def test_recursion_depth_handling(self) -> None:
+    from lxml import etree
+    # Create a deeply nested HTML structure
+    html_content = "<div>" * 150 + "test" + "</div>" * 150
+    tree = etree.HTML(html_content)
+    # This should not raise any errors due to deep recursion
+    result = list(_iterate_over_text(tree, max_depth=200))
+    self.assertEqual(result, ['test'])
+
