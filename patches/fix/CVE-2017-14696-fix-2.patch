
diff --git a/salt/crypt.py b/salt/crypt.py
index f4f65940d5..c75633df08 100644
--- a/salt/crypt.py
+++ b/salt/crypt.py
@@ -512,13 +512,19 @@ class AsyncAuth(object):
                                                                 crypt='clear',
                                                                 io_loop=self.io_loop)
         error = None
+        max_retries = self.opts.get('max_retries', 5)  # hypothetical new option for maximum retries
+        retries = 0
         while True:
+            if retries >= max_retries:
+                error = SaltClientError('Maximum retries for authentication reached')
+                break
             try:
                 creds = yield self.sign_in(channel=channel)
             except SaltClientError as exc:
                 error = exc
                 break
             if creds == 'retry':
+                retries += 1
                 if self.opts.get('detect_mode') is True:
                     error = SaltClientError('Detect mode is on')
                     break
@@ -534,6 +540,7 @@ class AsyncAuth(object):
                     log.debug('Authentication wait time is {0}'.format(acceptance_wait_time))
                 continue
             break
+            break
         if not isinstance(creds, dict) or 'aes' not in creds:
             if self.opts.get('detect_mode') is True:
                 error = SaltClientError('-|RETRY|-')
diff --git a/salt/transport/zeromq.py b/salt/transport/zeromq.py
index 1bb3abebe1..89e59d0666 100644
--- a/salt/transport/zeromq.py
+++ b/salt/transport/zeromq.py
@@ -598,7 +598,12 @@ class ZeroMQReqServerChannel(salt.transport.mixins.auth.AESReqServerMixin, salt.
 
         # intercept the "_auth" commands, since the main daemon shouldn't know
         # anything about our key auth
-        if payload['enc'] == 'clear' and payload.get('load', {}).get('cmd') == '_auth':
+            # Hypothetical check for rate limiting authentication attempts
+            if self._exceeds_auth_attempt_limit(stream):
+                log.error('Exceeded authentication attempts limit')
+                stream.close()
+                raise tornado.gen.Return()
+            stream.send(self.serial.dumps(self._auth(payload['load'])))
             stream.send(self.serial.dumps(self._auth(payload['load'])))
             raise tornado.gen.Return()
 
