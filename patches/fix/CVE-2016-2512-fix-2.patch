
diff --git a/django/utils/http.py b/django/utils/http.py
index 2dce7d3add..86430666f0 100644
--- a/django/utils/http.py
+++ b/django/utils/http.py
@@ -279,23 +279,18 @@ def is_same_domain(host, pattern):
     )
 
 
-def is_safe_url(url, host=None):
+def is_safe_url(url, allowed_hosts, require_https=False):
     """
     Return ``True`` if the url is a safe redirection (i.e. it doesn't point to
     a different host and uses a safe scheme).
 
     Always returns ``False`` on an empty url.
     """
-    if url is not None:
-        url = url.strip()
     if not url:
         return False
+    url = url.strip()
     # Chrome treats \ completely as /
     url = url.replace('\\', '/')
-    # Chrome considers any URL with more than two slashes to be absolute, but
-    # urlparse is not so flexible. Treat any url with three slashes as unsafe.
-    if url.startswith('///'):
-        return False
     url_info = urlparse(url)
     # Forbid URLs like http:///example.com - with a scheme, but without a hostname.
     # In that URL, example.com is not the hostname but, a path component. However,
@@ -303,10 +298,13 @@ def is_safe_url(url, host=None):
     # allow this syntax.
     if not url_info.netloc and url_info.scheme:
         return False
-    # Forbid URLs that start with control characters. Some browsers (like
-    # Chrome) ignore quite a few control characters at the start of a
-    # URL and might consider the URL as scheme relative.
-    if unicodedata.category(url[0])[0] == 'C':
+    if url_info.scheme and not url_info.scheme in ['http', 'https']:
+        return False
+    # Ensure the URL does not contain authentication information
+    if url_info.username is not None or url_info.password is not None:
+        return False
+    # If require_https is True, only allow 'https' scheme
+    if require_https and not url_info.scheme == 'https':
         return False
-    return ((not url_info.netloc or url_info.netloc == host) and
-            (not url_info.scheme or url_info.scheme in ['http', 'https']))
+    # Check if the host is allowed
+    return url_info.netloc in allowed_hosts or not url_info.netloc
diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py
index 6234e269ab..5e55db45ce 100644
--- a/tests/utils_tests/test_http.py
+++ b/tests/utils_tests/test_http.py
@@ -97,7 +97,18 @@ class TestUtilsHttp(unittest.TestCase):
                         'javascript:alert("XSS")',
                         '\njavascript:alert(x)',
                         '\x08//example.com',
-                        '\n'):
+                        '\n',
+                        'http://valid.com\\@example.com',
+                        'http://user:pass@example.com'):
+            self.assertFalse(http.is_safe_url(bad_url, allowed_hosts={'example.com'}))
+
+        for good_url in ('/view/?param=http://example.com',
+                         '/view/?param=https://example.com',
+                         'http://example.com/p/?param=http://bad.com',
+                         'http://example.com',
+                         'HTTPS://example.com',
+                         '/url%20with%20spaces/'):
+            self.assertTrue(http.is_safe_url(good_url, allowed_hosts={'example.com'}))
             self.assertFalse(http.is_safe_url(bad_url, host='testserver'), "%s should be blocked" % bad_url)
         for good_url in ('/view/?param=http://example.com',
                      '/view/?param=https://example.com',
